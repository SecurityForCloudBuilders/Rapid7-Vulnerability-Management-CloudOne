#!/usr/bin/env python3

DOCUMENTATION = '''
---
module: policy_on_r7_report.py

short_description: Retrieves CVEs discovered by Rapid7 Vulnerability
                   Management and assigns IPS rules to instances managed by
                   Cloud One Workload Security.

description:
    - "TODO"

options:
    none

author:
    - Markus Winkler (markus_winkler@trendmicro.com)
'''

EXAMPLES = '''
./policy_on_r7_report.py
'''

RETURN = '''
TODO
'''

import ssl
ssl._create_default_https_context = ssl._create_unverified_context
import urllib3
urllib3.disable_warnings()
import requests
from requests.auth import HTTPBasicAuth
import json
import yaml
import sys
import os
import time
import pickle
import os.path
import argparse
import pprint

pp = pprint.PrettyPrinter()

def r7_asset_search(r7_url, r7_username, r7_password, r7_asset):
    '''
    Search for an asset within Rapid7.
    Returns R7 asset id
    '''
    url = r7_url + "/api/3/assets/search"
    data = { "match": "all",
             "filters": [ { "field": "ip-address",
                            "operator": "is",
                            "value": r7_asset } ]
           }
    post_header = { "Accept": "application/json;charset=UTF-8",
                    "Content-type": "application/json" }
    response = requests.post(url,
                             data=json.dumps(data),
                             headers=post_header,
                             verify=False,
                             auth=HTTPBasicAuth(r7_username, r7_password)).json()

    if 'status' in response:
        if response['status'] >= 400:
            if "arguments supplied" in response['message']:
                raise Exception("Asset not found. " + response['message'])
            else:
                raise Exception("Authentication to Rapid7 not successful"
                            + " or service unavailable. "
                            + response['message'])

    if 'resources' not in response:
        raise KeyError(response['message'])

    return (response['resources'][0]['id'])

def r7_asset_vulnerabilities(r7_url, r7_username, r7_password, asset_id):
    '''
    Retrieve vulnerabilities of asset
    Returns a dictionary of vulnerailities (key) and cves (value set))
    for the given asset
    '''
    # Return dictionary
    asset_vuls_cves = {}

    url = r7_url + "/api/3/assets/"  + str(asset_id) + "/vulnerabilities?size=10000"

    response = requests.get(url,
                            verify=False,
                            auth=HTTPBasicAuth(r7_username, r7_password)).json()

    if 'status' in response:
        if response['status'] >= 400:
            raise Exception("Authentication to Rapid7 not successful"
                          + " or service unavailable.\n"
                          + response['message'])

    asset_cves = set()

    for vul in response['resources']:
        asset_cves = r7_vulnerability_cves(r7_url,
                                           r7_username,
                                           r7_password,
                                           vul['id'])
        cves = set()

        if asset_cves != "":
            for cve in asset_cves:
                cves.add(cve)
        asset_vuls_cves[str(vul['id']).strip()] = cves

    return asset_vuls_cves

def r7_vulnerability_cves(r7_url, r7_username, r7_password, vul_id):
    '''
    Retrieve cves of vulnerability
    Returns a set of cves if present in the vulnerability
    '''
    url = r7_url + "/api/3/vulnerabilities/"  + str(vul_id)

    response = requests.get(url,
                            verify=False,
                            auth=HTTPBasicAuth(r7_username, r7_password)).json()

    if 'status' in response:
        if response['status'] >= 400:
            raise Exception("Authentication to Rapid7 not successful"
                          + " or service unavailable.\n"
                          + response['message'])

    if 'cves' in response:
        return response['cves']
    else:
        return ""

def r7_create_exception_for_instance(r7_url,
                                     r7_username,
                                     r7_password,
                                     asset_id,
                                     vul_id):
    '''
    Create an exception for a given vulnerability and instance
    '''
    submitter_name = "nxadmin"#
    submitter_user = 1

    url = r7_url + "/api/3/vulnerability_exceptions"
    data = { "review": { "comment": "Auto approved by submitter." },
             "scope": { "id": asset_id,
                        "type": "instance",
                        "vulnerability": vul_id
             },
             "state": "approved",
             "submit": { "comment": "Deep Security IPS rules active",
                         "name": submitter_name,
                         "reason": "Compensating Control",
                         "user": submitter_user
             }
           }
    post_header = { "Accept": "application/json;charset=UTF-8",
                    "Content-type": "application/json" }
    response = requests.post(url,
                             data=json.dumps(data),
                             headers=post_header,
                             verify=False,
                             auth=HTTPBasicAuth(r7_username, r7_password)).json()

    if 'status' in response:
        if response['status'] == 200:
            print("Exception for " + vul_id + " created.\n"
                + response['message'])
            return 0
        if response['status'] >= 400:
            if "already exists" in response['message']:
                print("Exception for " + vul_id + " already exists.")
            else:
                raise Exception("Authentication to Rapid7 not successful"
                              + " or service unavailable. "
                              + response['message'])

def build_rules_cves_map(dsm_url, api_key):
    '''
    Build dictionary of intrusion prevention rules with the ability to cover CVEs
    '''
    # Constants
    RESULT_SET_SIZE = 5000

    # Return dictionary
    rules_cves = {}

    dict_len = 0
    offset = 0
    while(True):

        url = dsm_url + "/api/intrusionpreventionrules/search"
        data = { "maxItems": RESULT_SET_SIZE,
                 "searchCriteria": [ { "fieldName": "CVE",
                                       "stringTest": "not-equal",
                                       "stringValue": "" },
                                     { "fieldName": "ID",
                                       "idTest": "greater-than-or-equal",
                                       "idValue": offset },
                                     { "fieldName": "ID",
                                       "idTest": "less-than",
                                       "idValue": offset + RESULT_SET_SIZE } 
                                       ] }
        post_header = { "Content-type": "application/json",
                        "api-secret-key": api_key,
                        "api-version": "v1"}
        response = requests.post(url,
                                 data=json.dumps(data),
                                 headers=post_header,
                                 verify=False).json()

        # Error handling
        if 'message' in response:
            if response['message'] == "Invalid API Key":
                raise ValueError("Invalid API Key")
        if 'intrusionPreventionRules' not in response:
            if 'message' in response:
                raise KeyError(response['message'])
            else:
                raise KeyError(response)

        rules = response['intrusionPreventionRules']

        # Build dictionary ID: CVEs
        for rule in rules:
            cves = set()

            if 'CVE' in rule:
                for cve in rule['CVE']:
                    cves.add(str(cve.strip()))

            cves = sorted(cves)
            rules_cves[str(rule['ID']).strip()] = cves

        if len(rules_cves) != 0 and len(rules_cves) == dict_len:
            dict_len = len(rules_cves)
            print("Number of rules in dictionary: {}.".format(dict_len))
            break
        if len(rules_cves) != 0 and len(rules_cves) != dict_len:
            dict_len = len(rules_cves)

        offset += RESULT_SET_SIZE

    return rules_cves

def search_computer(hostname, dsm_url, api_key):
    '''
    Searches for computer and returns ID if present.
    Returns -1 is absent
    '''

    url = dsm_url + "/api/computers/search"
    data = { "maxItems": 1, "searchCriteria": [ { "fieldName": "hostName",
                                                  "stringTest": "equal",
                                                  "stringValue": hostname } ] }
    post_header = { "Content-type": "application/json",
                    "api-secret-key": api_key,
                    "api-version": "v1"}
    response = requests.post(url,
                             data=json.dumps(data),
                             headers=post_header,
                             verify=False).json()

    # Error handling
    if 'message' in response:
        if response['message'] == "Invalid API Key":
            raise ValueError("Invalid API Key")

    computer_id = -1
    computer_ruleIDs = {}

    if len(response['computers']) > 0:
        if 'ID' in response['computers'][0]:
            computer_id = response['computers'][0]['ID']

    if computer_id > -1:
        if 'ruleIDs' in response['computers'][0]['intrusionPrevention']:
            computer_ruleIDs = response['computers'][0]['intrusionPrevention']['ruleIDs']

    return { "ID": computer_id, "ruleIDs": computer_ruleIDs }

def search_ipsrule(identifier, dsm_url, api_key):
    '''
    Searches for IPS rule and returns ID if present.
    Returns -1 is absent
    '''
    url = dsm_url + "/api/intrusionpreventionrules/search"
    data = { "maxItems": 1,
             "searchCriteria": [ { "fieldName": "identifier",
                                   "stringTest": "equal",
                                   "stringValue": identifier
                                 } ] }
    post_header = { "Content-type": "application/json",
                    "api-secret-key": api_key,
                    "api-version": "v1"}
    response = requests.post(url,
                             data=json.dumps(data),
                             headers=post_header,
                             verify=False).json()

    # Error handling
    if 'intrusionPreventionRules' not in response:
        if 'message' in response:
            raise KeyError(response['message'])
        else:
            raise KeyError(response)

    rule_id = -1
    if len(response['intrusionPreventionRules']) > 0:
        if 'ID' in response['intrusionPreventionRules'][0]:
            rule_id = response['intrusionPreventionRules'][0]['ID']

    return { "ID": rule_id }

def rule_present(computer, rule, dsm_url, api_key):
    '''
    Ensure rule is present
    '''

    if rule['ID'] not in computer['ruleIDs']:

        print("Assigning rule {}.".format(str(rule['ID'])))

        url = dsm_url + "/api/computers/" + str(computer['ID']) + "/intrusionprevention/assignments"
        data = { "ruleIDs": str(rule['ID']) }
        post_header = { "Content-type": "application/json",
                        "api-secret-key": api_key,
                        "api-version": "v1"}
        computer_response = requests.post(url,
                                          data=json.dumps(data),
                                          headers=post_header,
                                          verify=False).json()

        # Rule added
        return 201

    print("Rule {} already assigned.".format(str(rule['ID'])))

    # Rule already present
    return 200

def rule_absent(computer, rule, dsm_url, api_key):
    '''
    Ensure rule is absent
    '''

    if rule['ID'] in computer['ruleIDs']:

        print("Unassigning rule {}.".format(str(rule['ID'])))

        url = dsm_url + "/api/computers/" + str(computer['ID']) + "/intrusionprevention/assignments/" + str(rule['ID'])
        data = { }
        post_header = { "Content-type": "application/json",
                        "api-secret-key": api_key,
                        "api-version": "v1"}
        computer_response = requests.delete(url,
                                            data=json.dumps(data),
                                            headers=post_header,
                                            verify=False).json()

        # Rule deleted
        return 201

    # Rule already absent
    return 200

def analyze_cves(dsm_url, api_key, rules_cves, cves_list, hostname, query):
    '''
    Checks cves against Deep Security database
    '''

    #
    # Module logic
    #
    # Retrieves intrusion prevention rules based on a list of given CVEs
    rules = set()
    rules_mapping = set()
    matched_list = set()
    unmatched_list = set()
    match_counter = 0
    unmatch_counter = len(query)

    for cve in query:
        matched = False
        attack_vector = ""
        criticality = ""
        if str(cve) in cves_list:
            attack_vector = " N"
            criticality = str(cves_list[str(cve)])
        else:
            attack_vector = " L"
        for rule in rules_cves:
            if str(cve) in rules_cves[str(rule)]:
                # Query rule identifier
                url = dsm_url + "/api/intrusionpreventionrules/search"
                data = { "maxItems": 1,
                         "searchCriteria": [ { "fieldName": "ID",
                                               "idTest": "equal",
                                               "idValue": str(rule) } ] }
                post_header = { "Content-type": "application/json",
                                "api-secret-key": api_key,
                                "api-version": "v1"}
                response = requests.post(url,
                                         data=json.dumps(data),
                                         headers=post_header,
                                         verify=False).json()
                rules.add(response['intrusionPreventionRules'][0]['identifier'])
                rules_mapping.add(
                  response['intrusionPreventionRules'][0]['identifier']
                  + " (" + str(cve) + ")" + attack_vector + criticality)
                matched_list.add(str(cve))
                if (matched == False):
                    match_counter += 1
                    unmatch_counter -= 1
                    matched = True
        if (matched == False):
            unmatched_list.add(str(cve))

    # Populate result set
    result = {"rules_covering": rules,
              "rules_mapping": rules_mapping,
              "cves_matched": matched_list,
              "cves_unmatched": unmatched_list,
              "cves_matched_count": match_counter,
              "cves_unmatched_count": unmatch_counter}

    return result

def assign_rules(dsm_url, api_key, resulting_cves, hostname):

    result = -1

    # Search for the computer object to modify it's policy
    print("Accessing computer object for {}.".format(hostname))
    computer = search_computer(hostname, dsm_url, api_key)

    if computer['ID'] == -1:
        print("Computer {} not found.".format(hostname))
        return result

    # Ensure, that matching ips rules are present within the computers policy
    print("Ensuring that the covering rules are set.")
    for identifier in resulting_cves['rules_covering']:
        result = rule_present(computer,
                              search_ipsrule(identifier, dsm_url, api_key),
                              dsm_url,
                              api_key)

    print("Policy updated.")

    return result

def main():

    with open("config.yml", "r") as ymlfile:
        cfg = yaml.load(ymlfile, Loader=yaml.FullLoader)

    asset_id = 0
    asset_cves = set()
    asset_vuls_cves = {}

    print("Running Deep Security Policy Manager for Rapid7 vulnerabilities.")
    print("Build IPS rules CVEs dictionary.")
    rules_cves = {}
    rules_cves = build_rules_cves_map(cfg['deepsecurity']['server'],
                                      cfg['deepsecurity']['api_key'])

    cves_list = {}
    # If a cves_network.cache file generated by nvd_extract_av_network is found,
    # we load the hash map to easily lookup the attack vector and the
    # riticality. Only network exploitable vulnerabilities currently
    # exist in the cache file
    if os.path.isfile('../cves_network.cache'):
        with open('../cves_network.cache', 'rb') as fp:
            cves_list = pickle.load(fp)
            print("CVEs cache with attack vector network loaded.")

    for computer in cfg['computers']:

        print("Requesting vulnerability scan report for {}.".format(computer))
        asset_id = r7_asset_search(cfg['rapid7']['server'],
                                   cfg['rapid7']['username'],
                                   cfg['rapid7']['password'],
                                   computer)
        asset_vuls_cves = r7_asset_vulnerabilities(cfg['rapid7']['server'],
                                                   cfg['rapid7']['username'],
                                                   cfg['rapid7']['password'],
                                                   asset_id)

        for vul_id in asset_vuls_cves:
            for cve in asset_vuls_cves[vul_id]:
                asset_cves.add(str(cve))

        print("CVEs to handle: {}.".format(str(len(asset_cves))))

        print("Check CVEs against Deep Security.")
        resulting_cves = analyze_cves(cfg['deepsecurity']['server'],
                                      cfg['deepsecurity']['api_key'],
                                      rules_cves,
                                      cves_list,
                                      computer,
                                      asset_cves)

        if resulting_cves['cves_matched_count']:
            print("Updating Deep Security Policy for {}.".format(computer))

            result = assign_rules(cfg['deepsecurity']['server'],
                                  cfg['deepsecurity']['api_key'],
                                  resulting_cves,
                                  computer)

            if result == -1:
                print("Name mismatch on computer {} in between Rapid7 and Deep Security.".format(computer))
                print("Nothing changed.")

            # Return key/value results
            print("Rules mapping: {}.".format(resulting_cves['rules_mapping']))

            # create exceptions for vulnerabilities with the matched cves
            #
            # NOTE:
            # currently, an exception is created when at least one cve from
            # a vulnerability is covered by DS! Improvement needed

            for cve in resulting_cves['cves_matched']:
                for vul_id in asset_vuls_cves:
                    if cve in asset_vuls_cves[vul_id]:

                        r7_create_exception_for_instance(cfg['rapid7']['server'],
                                                         cfg['rapid7']['username'],
                                                         cfg['rapid7']['password'],
                                                         asset_id,
                                                         vul_id)

        else:
            print("No matching IPS rules found.")
            result = -1

if __name__ == '__main__':
    main()
