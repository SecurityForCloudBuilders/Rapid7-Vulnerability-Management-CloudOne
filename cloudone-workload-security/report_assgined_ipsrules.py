#!/usr/bin/env python3

DOCUMENTATION = """
---
module: report_assgined_ipsrules.py

short_description: Creates a report containing all computer objects
                   and their IPS rules assigned.

description:
    - "TODO"

options:
    none

author:
    - Markus Winkler (markus_winkler@trendmicro.com)
"""

EXAMPLES = """
./report_assgined_ipsrules.py
"""

RETURN = """
Report in JSON
"""

import ssl

ssl._create_default_https_context = ssl._create_unverified_context
import urllib3

urllib3.disable_warnings()
import argparse
import json
import os
import os.path
import pickle
import pprint
import sys
import time

import requests
import yaml
from requests.auth import HTTPBasicAuth

pp = pprint.PrettyPrinter()

# Constants
RESULT_SET_SIZE = 5000


def build_id_identifier_name(dsm_url, api_key):
    """
    Create a dictionary with
    'ID': {'identifier',
           'name'}
    """

    # Return dictionary
    id_identifier_name = {}

    dict_len = 0
    offset = 0
    while True:

        url = dsm_url + "/api/intrusionpreventionrules/search"
        data = {
            "maxItems": RESULT_SET_SIZE,
            "searchCriteria": [
                {
                    "fieldName": "ID",
                    "idTest": "less-than",
                    "idValue": offset + RESULT_SET_SIZE,
                }
            ],
        }

        post_header = {
            "Content-type": "application/json",
            "api-secret-key": api_key,
            "api-version": "v1",
        }
        response = requests.post(
            url, data=json.dumps(data), headers=post_header, verify=False
        ).json()

        # Error handling
        if "message" in response:
            if response["message"] == "Invalid API Key":
                raise ValueError("Invalid API Key")

        rules = response["intrusionPreventionRules"]

        # Build dictionary
        for rule in rules:
            identifier_name = {
                "identifier": str(rule["identifier"]),
                "name": str(rule["name"]),
            }
            id_identifier_name[str(rule["ID"]).strip()] = identifier_name

        if len(id_identifier_name) != 0 and len(id_identifier_name) == dict_len:
            dict_len = len(id_identifier_name)
            print("Number of rules in dictionary: {}.".format(dict_len))
            break
        if len(id_identifier_name) != 0 and len(id_identifier_name) != dict_len:
            dict_len = len(id_identifier_name)

        offset += RESULT_SET_SIZE

    return id_identifier_name


def build_computer_rules(dsm_url, api_key, id_identifier_name):
    """
    Create a dictionary for computers with
     'ID': {'assignedRuleIDs': [],
            'assignedRuleIdentifiers': [],
            'displayName': '',
            'hostName': ''},
    """

    # Return dictionary
    computer_info = {}

    dict_len = 0
    offset = 0
    while True:

        url = dsm_url + "/api/computers/search"
        post_header = {
            "Content-type": "application/json",
            "api-secret-key": api_key,
            "api-version": "v1",
        }
        data = {
            "maxItems": RESULT_SET_SIZE,
            "searchCriteria": [
                {
                    "fieldName": "ID",
                    "idTest": "less-than",
                    "idValue": offset + RESULT_SET_SIZE,
                }
            ],
        }

        post_header = {
            "Content-type": "application/json",
            "api-secret-key": api_key,
            "api-version": "v1",
        }
        response = requests.post(
            url, data=json.dumps(data), headers=post_header, verify=False
        ).json()

        # Error handling
        if "message" in response:
            if response["message"] == "Invalid API Key":
                raise ValueError("Invalid API Key")

        computers = response["computers"]

        if len(computers) != 0 and len(computers) == dict_len:
            dict_len = len(computers)
            print("Number of Computers in dictionary: {}.".format(dict_len))
            break
        if len(computers) != 0 and len(computers) != dict_len:
            dict_len = len(computers)

        offset += RESULT_SET_SIZE

    # Build dictionary
    for computer in computers:

        print("Processing Computer ID: " + str(computer["ID"]))

        url = (
            dsm_url
            + "/api/computers/"
            + str(computer["ID"])
            + "/intrusionprevention/assignments"
        )
        post_header = {
            "Content-type": "application/json",
            "api-secret-key": api_key,
            "api-version": "v1",
        }
        computer_rules = requests.get(url, headers=post_header, verify=False).json()

        assignedRuleIdentifiers = []
        for rule in computer_rules["assignedRuleIDs"]:

            assignedRuleIdentifiers.append(
                id_identifier_name.get(str(rule), "").get("identifier", "None")
            )

        info = {
            "hostName": str(computer["hostName"]),
            "displayName": str(computer["displayName"]),
            "assignedRuleIDs": computer_rules["assignedRuleIDs"],
            "assignedRuleIdentifiers": assignedRuleIdentifiers,
        }

        computer_info[str(computer["ID"]).strip()] = info

    return computer_info


def main():

    with open("config.yml", "r") as ymlfile:
        cfg = yaml.load(ymlfile, Loader=yaml.FullLoader)

    print("Running Deep Security IPS Assignment Reporter.")

    print("Build IPS rules lookup table.")
    id_identifier_name = {}
    id_identifier_name = build_id_identifier_name(
        cfg["deepsecurity"]["server"], cfg["deepsecurity"]["api_key"]
    )

    print("Build Computer IPS rules table.")
    computer_rules = {}
    computer_rules = build_computer_rules(
        cfg["deepsecurity"]["server"],
        cfg["deepsecurity"]["api_key"],
        id_identifier_name,
    )

    pp.pprint(computer_rules)


if __name__ == "__main__":
    main()
